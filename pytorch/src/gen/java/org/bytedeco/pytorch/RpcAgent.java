// Targeted by JavaCPP version 1.5.11-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.functions.*;
import org.bytedeco.pytorch.chrono.*;
import org.bytedeco.pytorch.Module;
import org.bytedeco.javacpp.annotation.Cast;
import org.bytedeco.pytorch.helper.*;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.pytorch.global.torch.*;


// ``RpcAgent`` is the base class for sending and receiving RPC messages. It
// provides a unified ``send`` API for both request and response messages, and
// will invoke the given ``RequestCallback`` to process received requests. It
// should immediately become ready to serve request and accept response after
// construction.
@Namespace("torch::distributed::rpc") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class RpcAgent extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RpcAgent(Pointer p) { super(p); }

  // `WorkerInfo` is the globally unique identifier for this RpcAgent instance.
  // It contains a ``name_`` field and an ``id_`` field. ``name_`` is the
  // globally unique name for this ``RpcAgent``. It is up to the ``RpcAgent``
  // implementation to determine how to resolve names. ``id_`` is the globally
  // unique ID for this ``RpcAgent``. This should be determined by the
  // ``RpcAgent`` implementation.
  // The ``RequestCallback`` will be invoked to handle received requests. This
  // ``RpcAgent`` base class makes no assumption on the thread-safeness of the
  // ``RequestCallback``. ``RpcAgent`` implementations need to make sure that
  // its threading model conform to ``RequestCallback``'s requirement.
  // NB: RpcAgent implementations should not start serving requests until
  // ``start()`` is called, as there could be other contexts that have not been
  // initialized yet at this time.

  // Send a message to the ``RpcAgent`` of id ``to`` and returns a
  // ``JitFuture`` ptr. The implementation must be asynchronous, i.e., it
  // cannot block until it receives the response.
  //
  // If ``message.isRequest()`` is true, the ``JitFuture`` will be
  // completed when the response arrives. For other message types, the Future
  // should be ignored by the caller.
  public native @IntrusivePtr("c10::ivalue::Future") @Cast({"", "c10::intrusive_ptr<c10::ivalue::Future>&"}) Future send(
        @Const @ByRef WorkerInfo to,
        @IntrusivePtr("torch::distributed::rpc::Message") @Cast({"", "c10::intrusive_ptr<torch::distributed::rpc::Message>&"}) Message message,
        float rpcTimeoutSeconds/*=torch::distributed::rpc::kUnsetRpcTimeout*/,
        @Cast("const torch::distributed::rpc::DeviceMap*") @ByRef(nullValue = "torch::distributed::rpc::DeviceMap{}") SizeTStringMap deviceMap);
  public native @IntrusivePtr("c10::ivalue::Future") @Cast({"", "c10::intrusive_ptr<c10::ivalue::Future>&"}) Future send(
        @Const @ByRef WorkerInfo to,
        @IntrusivePtr("torch::distributed::rpc::Message") @Cast({"", "c10::intrusive_ptr<torch::distributed::rpc::Message>&"}) Message message);

  // Retries sending the message up to maxRetries times until an ACK is
  // received. The duration between consecutive sends is increased over
  // time using an exponential backoff algorithm.
  //
  // Sends ``message`` to the ``RpcAgent`` of id ``to`` and returns a
  // ``JitFuture`` ptr, just like send(). Caller can specify the maximum
  // number of retries for this RPC (default is 5), initial duration between
  // sends (default is 1000ms), and backoff constant (default is 1.5) by
  // passing in the RpcRetryOptions struct. This API might end up
  // executing a method twice on the remote end (it does not guarantee
  // exactly-once semantics). Therefore, the user must ensure their requests
  // are idempotent.
  public native @IntrusivePtr("c10::ivalue::Future") @Cast({"", "c10::intrusive_ptr<c10::ivalue::Future>&"}) Future sendWithRetries(
        @Const @ByRef WorkerInfo to,
        @IntrusivePtr("torch::distributed::rpc::Message") @Cast({"", "c10::intrusive_ptr<torch::distributed::rpc::Message>&"}) Message message,
        @ByVal(nullValue = "torch::distributed::rpc::RpcRetryOptions()") RpcRetryOptions retryOptions);
  public native @IntrusivePtr("c10::ivalue::Future") @Cast({"", "c10::intrusive_ptr<c10::ivalue::Future>&"}) Future sendWithRetries(
        @Const @ByRef WorkerInfo to,
        @IntrusivePtr("torch::distributed::rpc::Message") @Cast({"", "c10::intrusive_ptr<torch::distributed::rpc::Message>&"}) Message message);

  // Return a reference to the ``WorkerInfo`` of this RpcAgent.
  // NB: not using ``c10::optional<const std::string&>`` here because we might
  // need to create a separate RPC API lib and avoid forcing all ``RpcAgent``
  // implementations to depend on libtorch.
  public native @Const @ByRef WorkerInfo getWorkerInfo();

  // Return a reference to the ``WorkerInfo`` of the given ``workerName``.
  public native @Const @ByRef WorkerInfo getWorkerInfo(
        @StdString BytePointer workerName);
  public native @Const @ByRef WorkerInfo getWorkerInfo(
        @StdString String workerName);

  public native @Const @ByRef WorkerInfo getWorkerInfo(short id);

  public native @StdVector WorkerInfo getWorkerInfos();

  // Retrieve the timeout for all RPCs.
  public native @ByVal Milliseconds getRpcTimeout();

  // Set the timeout for all RPCs
  public native void setRpcTimeout(@Const @ByRef Milliseconds rpcTimeout);

  // Call sync and join all internal threads. This method should be called
  // before every RPC process exits.
  public native void join(@Cast("bool") boolean shutdown/*=false*/, float timeout/*=0*/);
  public native void join();

  // Synchronize the this process with other ``RpcAgent`` processes. Block until
  // all ``RpcAgent``s reach this method and send all pending messages.
  public native void sync();

  // Sets up backend-agnostic state for accepting requests. Currently, this
  // entails setting rpcAgentRunning_ to true, creating the retry thread, and
  // calling the backend's startImpl.
  public native void start();

  // Derived classes must override this function to start accepting requests.
  // This is used to initialize any backend-specific state. Users must call
  // start, not startImpl, to initialize the RPC Agent.
  public native void startImpl();

  // Stop accepting requests and shutdown the RPC framework as soon as possible
  // by terminating all RPC threads.
  public native void shutdown();

  // Derived classes must override this function to start accepting requests.
  // THis is used to clean up any backend-specific state. Users must call
  // shutdown, not shutdownImpl, to shutdown the RPC Agent.
  public native void shutdownImpl();

  // Check if current RPC agent is set.
  public static native @Cast("bool") boolean isCurrentRpcAgentSet();

  // Retrieve the valid current RPC agent.
  public static native @SharedPtr RpcAgent getCurrentRpcAgent();

  // Set the current RPC agent.
  public static native void setCurrentRpcAgent(@SharedPtr RpcAgent rpcAgent);

  // Retrieve metrics as KV map
  public native @ByVal ExtraFilesMap getMetrics();

  // Retrieve debug info in addition to metrics as KV map
  public native @ByVal ExtraFilesMap getDebugInfo();

  // Flag to control whether GIL wait times
  // should be profiled or not.
  public native void enableGILProfiling(@Cast("bool") boolean flag);

  // Retrieve wheher we should profile GIL wait times or not.
  public native @Cast("bool") boolean isGILProfilingEnabled();

  // Set type resolver that will be passed to JIT pickler to resolver type Ptr
  // based on type str.
  

  // Get the type resolver
  

  // Retrieves the device map for the provided destination worker.
  public native @ByVal @Cast("torch::distributed::rpc::DeviceMap*") SizeTStringMap getDeviceMap(@Const @ByRef WorkerInfo dst);

  // Retrieve the (non-CPU) devices that are supported by the agent.
  public native @StdVector Device getDevices();
}
